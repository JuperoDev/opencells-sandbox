"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _prompts = _interopRequireDefault(require("prompts"));

var _path = _interopRequireDefault(require("path"));

var _core = require("./core.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-console, import/no-cycle */

/**
 * Options for the generator
 * @typedef {object} GeneratorOptions
 * @property {string} [tagName] the dash-case tag name
 * @property {string} [destinationPath='auto'] path to output to. default value 'auto' will output to current working directory
 * @property {'scaffold'} [type='scaffold'] path to output to. default value 'auto' will output to current working directory
 * @property {'true'|'false'} [writeToDisk] whether to write to disk
 * @property {'yarn'|'npm'|'false'} [installDependencies] whether and with which tool to install dependencies
 */

/**
 * dash-case to PascalCase
 * @param  {string} tagName dash-case tag name
 * @return {string}         PascalCase class name
 */
function getClassName(tagName) {
  return tagName.split('-').reduce((previous, part) => previous + part.charAt(0).toUpperCase() + part.slice(1), '');
}

class Generator {
  constructor() {
    /**
     * @type {GeneratorOptions}
     */
    this.options = {
      destinationPath: 'auto'
    };
    this.templateData = {};
    this.wantsNpmInstall = true;
    this.wantsWriteToDisk = true;
    this.wantsRecreateInfo = true;
    this.generatorName = '@open-wc';
  }

  execute() {
    if (this.options.tagName) {
      const {
        tagName
      } = this.options;
      const className = getClassName(tagName);
      this.templateData = { ...this.templateData,
        tagName,
        className
      };

      if (this.options.destinationPath === 'auto') {
        this.options.destinationPath = process.cwd();

        if (this.options.type === 'scaffold') {
          this.options.destinationPath = _path.default.join(process.cwd(), tagName);
        }
      }
    }
  }

  destinationPath(destination = '') {
    return _path.default.join(this.options.destinationPath, destination);
  }

  copyTemplate(from, to, ejsOptions = {}) {
    (0, _core.copyTemplate)(from, to, this.templateData, ejsOptions);
  }

  copyTemplateJsonInto(from, to, options = {
    mode: 'merge'
  }, ejsOptions = {}) {
    (0, _core.copyTemplateJsonInto)(from, to, this.templateData, options, ejsOptions);
  }

  async copyTemplates(from, to = this.destinationPath(), ejsOptions = {}) {
    return (0, _core.copyTemplates)(from, to, this.templateData, ejsOptions);
  }

  async end() {
    if (this.wantsWriteToDisk) {
      this.options.writeToDisk = await (0, _core.writeFilesToDisk)();
    }

    if (this.wantsNpmInstall) {
      const answers = await (0, _prompts.default)([{
        type: 'select',
        name: 'installDependencies',
        message: 'Do you want to install dependencies?',
        choices: [{
          title: 'No',
          value: 'false'
        }, {
          title: 'Yes, with yarn',
          value: 'yarn'
        }, {
          title: 'Yes, with npm',
          value: 'npm'
        }]
      }], {
        onCancel: () => {
          process.exit();
        }
      });
      this.options.installDependencies = answers.installDependencies;
      const {
        installDependencies
      } = this.options;

      if (installDependencies === 'yarn' || installDependencies === 'npm') {
        await (0, _core.installNpm)(this.options.destinationPath, installDependencies);
      }
    }

    if (this.wantsRecreateInfo) {
      console.log('');
      console.log('If you want to rerun this exact same generator you can do so by executing:');
      console.log((0, _core.optionsToCommand)(this.options, this.generatorName));
    }
  }

}

var _default = Generator;
exports.default = _default;